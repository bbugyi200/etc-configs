diff --git a/vimode.py b/vimode.py
index 06f9c28..985df0a 100755
--- a/vimode.py
+++ b/vimode.py
@@ -22,6 +22,7 @@
 
 
 import csv
+import functools
 import json
 import os
 import re
@@ -30,8 +31,8 @@ try:
     from StringIO import StringIO
 except ImportError:
     from io import StringIO
-import time
 import sys
+import time
 
 import weechat
 
@@ -190,7 +191,7 @@ def cmd_nmap(args):
     See Also:
         `cmd_unmap()`.
     """
-    args = args.strip()
+    args = args.lstrip()
     if not args:
         mappings = vimode_settings['user_mappings']
         if mappings:
@@ -1044,6 +1045,162 @@ VI_KEYS = {'j': "/window scroll_down",
 for i in range(10, 99):
     VI_KEYS['\x01[j%s' % i] = "/buffer %s" % i
 
+class UserMapping:
+    """Wraps User Mapping
+
+    Enables multiple actions to be defined by a single mapping.
+    """
+    def __init__(self, cmd):
+        self.cmd = cmd
+        self.count = 0
+        self.bad_sequence = ""
+
+    def __call__(self, buf, input_line, cur, count):
+        for _ in range(max(count, 1)):
+            bad_sequence_list = []
+            for action in self.get_cmd_actions(self.cmd, first_call=True):
+                debug_print('action', action)
+                debug_print('buf', buf)
+                debug_print('input_line', input_line)
+                debug_print('cur', cur)
+                debug_print('count', count)
+
+                if self.bad_sequence:
+                    bad_sequence_list.append(self.bad_sequence)
+
+                action(buf, input_line, cur, self.count)
+
+                self.count = 0
+                self.bad_sequence = ""
+
+                buf = weechat.current_buffer()
+                input_line = weechat.buffer_get_string(buf, "input")
+                cur = weechat.buffer_get_integer(buf, "input_pos")
+
+            if self.bad_sequence:
+                bad_sequence_list.append(self.bad_sequence)
+                self.bad_sequence = ""
+
+            for bad_seq in bad_sequence_list:
+                error_msg = 'Failed to parse "{}" sequence ' \
+                            'in nmap binding.'.format(bad_seq)
+                print_warning(error_msg)
+
+    def get_cmd_actions(self, cmd, *, first_call=False):
+        """Generator for Callable Actions
+
+        Yields:
+            Callable object: func(buf, input_line, cur, count)
+        """
+        if cmd == '':
+            return
+
+        match = re.match('^[1-9][0-9]*', cmd)
+        if match:
+            end = match.end()
+            self.count += int(cmd[:end])
+            yield from self.get_cmd_actions(cmd[end:])
+            return
+
+        lcmd = cmd.lower()
+
+        command_pttrn = '[:/].*?<cr>'
+        old_style_cmd_conditions = [
+            first_call,
+            cmd[0] == '/',
+            re.match(command_pttrn, lcmd) is None,
+        ]
+
+        if all(old_style_cmd_conditions):
+            yield functools.partial(do_command, cmd)
+            return
+
+        debug_print('cmd', cmd)
+
+        if lcmd.startswith('<cr>'):
+            yield functools.partial(do_command, '/input return')
+            yield from self.get_cmd_actions(cmd[4:])
+            return
+
+        if mode == 'INSERT':
+            match = re.search('<(esc|cr)>', lcmd)
+            end = match.start() if match else len(cmd)
+
+            yield self.insert_input_action(cmd[:end])
+
+            if match:
+                group = match.group()
+                if group == '<esc>':
+                    start = match.end()
+                elif group == '<cr>':
+                    start = match.start()
+
+                set_mode('NORMAL')
+                yield from self.get_cmd_actions(cmd[start:])
+
+            return
+
+        print(1)
+
+        for keys, command in VI_KEYS.items():
+            if cmd.startswith(keys):
+                debug_print('keys', keys)
+                debug_print('command', command)
+
+                if isinstance(command, str):
+                    yield functools.partial(do_command, command)
+                else:
+                    yield command
+                debug_print('cmd[len(keys)', cmd[len(keys):])
+                yield from self.get_cmd_actions(cmd[len(keys):])
+                return
+
+        print(2)
+
+        for motion in VI_MOTIONS:
+            if cmd.startswith(motion):
+                yield functools.partial(do_motion, motion)
+                yield from self.get_cmd_actions(cmd[len(motion):])
+                return
+
+        print(3)
+
+        if len(cmd) > 1 and cmd[0] in VI_OPERATORS:
+            for motion in VI_MOTIONS:
+                if cmd[1:].startswith(motion):
+                    yield functools.partial(do_operator, cmd[:len(motion) + 1])
+                    yield from self.get_cmd_actions(cmd[len(motion) + 1:])
+                    return
+
+        print(4)
+
+        match = re.match(command_pttrn, lcmd)
+        if match:
+            end = match.end()
+            yield functools.partial(do_command, '/{}'.format(cmd[1:end - 4]))
+            yield from self.get_cmd_actions(cmd[end:])
+            return
+
+        if cmd[0] in (':', '/'):
+            debug_print('/command [options]', cmd)
+            self.bad_sequence += cmd
+            return
+
+        self.bad_sequence += cmd[0]
+        yield from self.get_cmd_actions(cmd[1:])
+
+    def insert_input_action(self, new_input):
+        """Factory for Action that Sends Input to Command-Line"""
+        def action(buf, input_line, cur, count):
+            p = int(cur)
+            final_input = '{}{}{}'.format(input_line[:p],
+                                          new_input,
+                                          input_line[p:])
+            weechat.buffer_set(buf, "input", final_input)
+            new_pos = str(len(new_input) + p)
+            weechat.buffer_set(buf, "input_pos", new_pos)
+        return action
+
 
 # Key handling.
 # =============
@@ -1298,21 +1455,13 @@ def cb_key_combo_default(data, signal, signal_data):
         if vi_keys not in ['u', '\x01R']:
             add_undo_history(buf, input_line)
         if isinstance(VI_KEYS[vi_keys], str):
-            for _ in range(max(count, 1)):
-                weechat.command("", VI_KEYS[vi_keys])
-                current_cur = weechat.buffer_get_integer(buf, "input_pos")
-                set_cur(buf, input_line, current_cur)
+            do_command(VI_KEYS[vi_keys], buf, input_line, cur, count)
         else:
             VI_KEYS[vi_keys](buf, input_line, cur, count)
     # It's a motion (e.g. "w") — call `motion_X()` where X is the motion, then
     # set the cursor's position to what that function returned.
     elif vi_keys in VI_MOTIONS:
-        if vi_keys in SPECIAL_CHARS:
-            func = "motion_%s" % SPECIAL_CHARS[vi_keys]
-        else:
-            func = "motion_%s" % vi_keys
-        end, _, _ = globals()[func](input_line, cur, count)
-        set_cur(buf, input_line, end)
+        do_motion(vi_keys, buf, input_line, cur, count)
     # It's an operator + motion (e.g. "dw") — call `motion_X()` (where X is
     # the motion), then we call `operator_Y()` (where Y is the operator)
     # with the position `motion_X()` returned. `operator_Y()` should then
@@ -1320,19 +1469,7 @@ def cb_key_combo_default(data, signal, signal_data):
     elif (len(vi_keys) > 1 and
           vi_keys[0] in VI_OPERATORS and
           vi_keys[1:] in VI_MOTIONS):
-        add_undo_history(buf, input_line)
-        if vi_keys[1:] in SPECIAL_CHARS:
-            func = "motion_%s" % SPECIAL_CHARS[vi_keys[1:]]
-        else:
-            func = "motion_%s" % vi_keys[1:]
-        pos, overwrite, catching = globals()[func](input_line, cur, count)
-        # If it's a catching motion, we don't want to call the operator just
-        # yet -- this code will run again when the motion is complete, at which
-        # point we will.
-        if not catching:
-            oper = "operator_%s" % vi_keys[0]
-            globals()[oper](buf, input_line, cur, pos, overwrite)
-    # The combo isn't completed yet (e.g. just "d").
+        do_operator(vi_keys, buf, input_line, cur, count)
     else:
         return weechat.WEECHAT_RC_OK_EAT
 
@@ -1462,6 +1599,8 @@ def load_user_mappings():
     if vimode_settings['user_mappings']:
         mappings.update(json.loads(vimode_settings['user_mappings']))
     vimode_settings['user_mappings'] = mappings
+    for k, v in mappings.items():
+        VI_KEYS[k] = UserMapping(v)
 
 
 # Command-line execution.
@@ -1582,6 +1721,35 @@ def cb_vimode_cmd(data, buf, args):
 
 # Motions/keys helpers.
 # ---------------------
+def do_command(cmd, buf, input_line, cur, count):
+    """Execute WeeChat Command"""
+    for _ in range(max(count, 1)):
+        weechat.command("", cmd)
+        current_cur = weechat.buffer_get_integer(buf, "input_pos")
+        set_cur(buf, input_line, current_cur)
+
+def do_motion(keys, buf, input_line, cur, count):
+    """Perform Vim-like Motion"""
+    if keys in SPECIAL_CHARS:
+        func = "motion_%s" % SPECIAL_CHARS[keys]
+    else:
+        func = "motion_%s" % keys
+    end, _, _ = globals()[func](input_line, cur, count)
+    set_cur(buf, input_line, end)
+
+def do_operator(keys, buf, input_line, cur, count):
+    add_undo_history(buf, input_line)
+    if keys[1:] in SPECIAL_CHARS:
+        func = "motion_%s" % SPECIAL_CHARS[keys[1:]]
+    else:
+        func = "motion_%s" % keys[1:]
+    pos, overwrite, catching = globals()[func](input_line, cur, count)
+    # If it's a catching motion, we don't want to call the operator just
+    # yet -- this code will run again when the motion is complete, at which
+    # point we will.
+    if not catching:
+        oper = "operator_%s" % keys[0]
+        globals()[oper](buf, input_line, cur, pos, overwrite)
 
 def get_pos(data, regex, cur, ignore_cur=False, count=0):
     """Return the position of `regex` match in `data`, starting at `cur`.
@@ -1679,6 +1847,7 @@ def get_keys_and_count(combo):
             we should handle. User mappings are also expanded.
         count (int): count for `combo`.
     """
+
     # Look for a potential match (e.g. "d" might become "dw" or "dd" so we
     # accept it, but "d9" is invalid).
     matched = False
@@ -1695,9 +1864,6 @@ def get_keys_and_count(combo):
                 break
         combo = combo.replace(count, "", 1)
         count = int(count)
-    # It's a user defined key. Expand it.
-    if combo in vimode_settings['user_mappings']:
-        combo = vimode_settings['user_mappings'][combo]
     # It's a WeeChat command.
     if not matched and combo.startswith("/"):
         matched = True
@@ -1746,6 +1912,14 @@ def get_keys_and_count(combo):
 
 # Other helpers.
 # --------------
+def debug_print(name, value):
+    """Prints the Name and Value of a Variable
+
+    Toggle the DEBUGGING_ENABLED to enable/disable debug output.
+    """
+    DEBUGGING_ENABLED = True
+    if DEBUGGING_ENABLED:
+        print('[DEBUG] {} = {}'.format(name, value))
 
 def set_mode(arg):
     """Set the current mode and update the bar mode indicator."""
