diff --git a/black.py b/black.py
index 68c0052..ef7c418 100644
--- a/black.py
+++ b/black.py
@@ -1,5 +1,7 @@
 import ast
 import asyncio
+from abc import ABCMeta, abstractmethod
+from collections import defaultdict
 from concurrent.futures import Executor, ProcessPoolExecutor
 from contextlib import contextmanager
 from datetime import datetime
@@ -21,6 +23,7 @@ import traceback
 from typing import (
     Any,
     Callable,
+    ClassVar,
     Collection,
     Dict,
     Generator,
@@ -28,11 +31,13 @@ from typing import (
     Iterable,
     Iterator,
     List,
+    NamedTuple,
     Optional,
     Pattern,
     Sequence,
     Set,
     Tuple,
+    Type,
     TypeVar,
     Union,
     cast,
@@ -60,6 +65,17 @@ DEFAULT_LINE_LENGTH = 88
 DEFAULT_EXCLUDES = r"/(\.eggs|\.git|\.hg|\.mypy_cache|\.nox|\.tox|\.venv|\.svn|_build|buck-out|build|dist)/"  # noqa: B950
 DEFAULT_INCLUDES = r"\.pyi?$"
 CACHE_DIR = Path(user_cache_dir("black", version=__version__))
+STRING_PREFIX_CHARS: Final = "furbFURB"  # All possible string prefix characters.
+STRING_REGEXP: Final = (
+    "["
+    + STRING_PREFIX_CHARS
+    + "]{0,"
+    + str(len(STRING_PREFIX_CHARS))
+    + r"}(?:'(?:[^']|\\')*?[^\\]'|\"(?:[^\"]|\\\")*?[^\\]\")"
+)
+STRING_GROUP_REGEXP: Final = "(" + STRING_REGEXP + ")"
+STRING_DOT_OR_PERC_REGEXP: Final = r"(?:\.[A-Za-z0-9_]+\(.*?\)| ?% ?.*)?"
+STRING_END_COMMENT_REGEXP: Final = r" *(?:#.*)?"
 
 
 # types
@@ -92,10 +108,21 @@ class CannotSplit(Exception):
     """A readable split that fits the allotted line length is impossible."""
 
 
+class STError(CannotSplit):
+    """Raised when a StringTransformer instance fails."""
+
+
 class InvalidInput(ValueError):
     """Raised when input source code fails all parse attempts."""
 
 
+Ok = TypeVar("Ok")
+Err = TypeVar("Err", bound=Exception)
+Result = Union[Ok, Err]
+STResult = Result[Ok, STError]  # StringTransformer Result
+STMatchResult = STResult[str]  # StringTransformer Match Result
+
+
 class WriteBack(Enum):
     NO = 0
     YES = 1
@@ -287,16 +314,16 @@ def target_version_option_callback(
     help=(
         "Allow using Python 3.6-only syntax on all input files.  This will put "
         "trailing commas in function signatures and calls also after *args and "
-        "**kwargs. Deprecated; use --target-version instead. "
-        "[default: per-file auto-detection]"
+        "**kwargs. Deprecated; use --target-version instead. [default: per-file "
+        "auto-detection]"
     ),
 )
 @click.option(
     "--pyi",
     is_flag=True,
     help=(
-        "Format all input files like typing stubs regardless of file extension "
-        "(useful when piping source on standard input)."
+        "Format all input files like typing stubs regardless of file extension (useful "
+        "when piping source on standard input)."
     ),
 )
 @click.option(
@@ -309,9 +336,9 @@ def target_version_option_callback(
     "--check",
     is_flag=True,
     help=(
-        "Don't write the files back, just return the status.  Return code 0 "
-        "means nothing would change.  Return code 1 means some files would be "
-        "reformatted.  Return code 123 means there was an internal error."
+        "Don't write the files back, just return the status.  Return code 0 means "
+        "nothing would change.  Return code 1 means some files would be reformatted. "
+        "Return code 123 means there was an internal error."
     ),
 )
 @click.option(
@@ -330,10 +357,9 @@ def target_version_option_callback(
     default=DEFAULT_INCLUDES,
     help=(
         "A regular expression that matches files and directories that should be "
-        "included on recursive searches.  An empty value means all files are "
-        "included regardless of the name.  Use forward slashes for directories on "
-        "all platforms (Windows, too).  Exclusions are calculated first, inclusions "
-        "later."
+        "included on recursive searches.  An empty value means all files are included "
+        "regardless of the name.  Use forward slashes for directories on all platforms "
+        "(Windows, too).  Exclusions are calculated first, inclusions later."
     ),
     show_default=True,
 )
@@ -354,8 +380,8 @@ def target_version_option_callback(
     "--quiet",
     is_flag=True,
     help=(
-        "Don't emit non-error messages to stderr. Errors are still emitted; "
-        "silence those with 2>/dev/null."
+        "Don't emit non-error messages to stderr. Errors are still emitted; silence "
+        "those with 2>/dev/null."
     ),
 )
 @click.option(
@@ -414,8 +440,8 @@ def main(
             versions = set(target_version)
     elif py36:
         err(
-            "--py36 is deprecated and will be removed in a future version. "
-            "Use --target-version py36 instead."
+            "--py36 is deprecated and will be removed in a future version. Use "
+            "--target-version py36 instead."
         )
         versions = PY36_VERSIONS
     else:
@@ -766,7 +792,10 @@ def format_str(src_contents: str, *, mode: FileMode) -> FileContent:
         for _ in range(before):
             dst_contents.append(str(empty_line))
         for line in split_line(
-            current_line, line_length=mode.line_length, features=split_line_features
+            current_line,
+            line_length=mode.line_length,
+            normalize_strings=mode.string_normalization,
+            features=split_line_features,
         ):
             dst_contents.append(str(line))
     return "".join(dst_contents)
@@ -1556,6 +1585,14 @@ class Line:
             n.type in TEST_DESCENDANTS for n in subscript_start.pre_order()
         )
 
+    def clone(self) -> "Line":
+        return Line(
+            depth=self.depth,
+            bracket_tracker=self.bracket_tracker,
+            inside_brackets=self.inside_brackets,
+            should_explode=self.should_explode,
+        )
+
     def __str__(self) -> str:
         """Render the line."""
         if not self:
@@ -2396,15 +2433,12 @@ def make_comment(content: str) -> str:
 def split_line(
     line: Line,
     line_length: int,
-    inner: bool = False,
+    normalize_strings: bool,
     features: Collection[Feature] = (),
 ) -> Iterator[Line]:
     """Split a `line` into potentially many lines.
 
     They should fit in the allotted `line_length` but might not be able to.
-    `inner` signifies that there were a pair of brackets somewhere around the
-    current `line`, possibly transitively. This means we can fallback to splitting
-    by delimiters if the LHS/RHS don't yield any results.
 
     `features` are syntactical features that may be used in the output.
     """
@@ -2412,7 +2446,7 @@ def split_line(
         yield line
         return
 
-    line_str = str(line).strip("\n")
+    line_str = line_to_string(line)
 
     if (
         not line.contains_uncollapsable_type_comments()
@@ -2445,10 +2479,38 @@ def split_line(
             # See #762 and #781 for the full story.
             yield from right_hand_split(line, line_length=1, features=features)
 
+        def init_st(ST: Type[StringTransformer]) -> StringTransformer:
+            """Initialize String Transformer"""
+            return ST(line_length, normalize_strings)
+
+        string_merge = init_st(StringMerger)
+        string_arg_comma_strip = init_st(StringArgCommaStripper)
+        string_parens_strip = init_st(StringParensStripper)
+        string_arith_expr_split = init_st(StringArithExprSplitter)
+        string_term_split = init_st(StringTermSplitter)
+        string_expr_split = init_st(StringExprSplitter)
+
         if line.inside_brackets:
-            split_funcs = [delimiter_split, standalone_comment_split, rhs]
+            split_funcs = [
+                string_merge,
+                string_arg_comma_strip,
+                string_parens_strip,
+                string_arith_expr_split,
+                delimiter_split,
+                standalone_comment_split,
+                string_term_split,
+                string_expr_split,
+                rhs,
+            ]
         else:
-            split_funcs = [rhs]
+            split_funcs = [
+                string_merge,
+                string_arg_comma_strip,
+                string_parens_strip,
+                string_term_split,
+                string_expr_split,
+                rhs,
+            ]
     for split_func in split_funcs:
         # We are accumulating lines in `result` because we might want to abort
         # mission and return the original line in the end, or attempt a different
@@ -2461,7 +2523,10 @@ def split_line(
 
                 result.extend(
                     split_line(
-                        l, line_length=line_length, inner=True, features=features
+                        l,
+                        line_length=line_length,
+                        normalize_strings=normalize_strings,
+                        features=features,
                     )
                 )
         except CannotSplit:
@@ -2475,7 +2540,817 @@ def split_line(
         yield line
 
 
-def left_hand_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
+@dataclass  # type: ignore
+class StringTransformer(metaclass=ABCMeta):
+    line_length: int
+    normalize_strings: bool
+
+    @abstractmethod
+    def __call__(self, line: Line, features: Collection[Feature]) -> Iterator[Line]:
+        pass
+
+
+class StringTransformerMixin(StringTransformer):
+    @abstractmethod
+    def _do_match(self, line: Line) -> STMatchResult:
+        pass
+
+    @abstractmethod
+    def _do_transform(self, line: Line, string_idx: int) -> Iterator[STResult[Line]]:
+        pass
+
+    def __call__(self, line: Line, _features: Collection[Feature]) -> Iterator[Line]:
+        result = self._do_match(line)
+
+        if isinstance(result, STError):
+            raise CannotSplit(
+                f"The string splitter {self.__class__.__name__} does not recognize"
+                " this line as one that it can split."
+            ) from result
+
+        idx_result = self._get_string_idx(line.leaves, result)
+        if isinstance(idx_result, ValueError):
+            raise RuntimeError(
+                f"Logic Error in `{self.__class__.__name__}._do_match` method."
+            ) from idx_result
+
+        string_idx = idx_result
+
+        for line_result in self._do_transform(line, string_idx):
+            if isinstance(line_result, STError):
+                raise CannotSplit(
+                    "StringTransformer failed while attempting to transform string."
+                ) from line_result
+            yield line_result
+
+    @staticmethod
+    def _regex_match(line: Line, pattern: str) -> STMatchResult:
+        line_str = line_to_string(line)
+        match = re.match(pattern, line_str)
+
+        if match is not None:
+            result = match.groups()[0]
+            assert isinstance(result, str)
+            return result
+        else:
+            return STError(
+                f"Line ({line_str}) does not match regular expression pattern"
+                f" ({pattern})."
+            )
+
+    def _get_string_idx(
+        self, leaves: List[Leaf], string_value: str
+    ) -> Result[int, ValueError]:
+        for i, leaf in enumerate(leaves):
+            if leaf.type == token.STRING and leaf.value == string_value:
+                return i
+
+        return ValueError(
+            f"{self.__class__.__name__} claims to know the string value is"
+            f" {string_value} but is unable to find a leaf in this line that contains"
+            " this string."
+        )
+
+
+@dataclass
+class CustomSplit:
+    has_prefix: bool
+    break_idx: int
+
+
+CUSTOM_SPLITS: Dict[LeafID, Tuple[CustomSplit, ...]] = defaultdict(tuple)
+
+
+class StringMerger(StringTransformerMixin):
+    def _do_match(self, line: Line) -> STMatchResult:
+        regex_result = self._regex_match(
+            line,
+            "^ *"
+            + r"(?:[^'\"]|"
+            + STRING_REGEXP
+            + ")*?"
+            + STRING_GROUP_REGEXP
+            + "(?: *"
+            + STRING_REGEXP
+            + ")+.*$",
+        )
+
+        if isinstance(regex_result, str):
+            return regex_result
+
+        for leaf in line.leaves:
+            if (
+                leaf.type == token.STRING
+                and "\\\n" in leaf.value
+                and leaf.value.lstrip(STRING_PREFIX_CHARS)[:3] not in {'"""', "'''"}
+            ):
+                return leaf.value
+
+        error = STError(
+            f"This line ({line_to_string(line)}) has no strings that need merging."
+        )
+        error.__cause__ = regex_result
+        return error
+
+    def _do_transform(self, line: Line, string_idx: int) -> Iterator[STResult[Line]]:
+        new_line = line
+        rblc_result = self.__remove_backslash_line_continuation_chars(
+            new_line, string_idx
+        )
+        if isinstance(rblc_result, Line):
+            new_line = rblc_result
+
+        mfsg_result = self.__merge_first_string_group(new_line, string_idx)
+        if isinstance(mfsg_result, Line):
+            new_line = mfsg_result
+
+        if isinstance(rblc_result, STError) and isinstance(mfsg_result, STError):
+            mfsg_result.__cause__ = rblc_result
+
+            error = STError("StringMerger failed to merge any strings in this line.")
+            error.__cause__ = mfsg_result
+            yield error
+        else:
+            yield new_line
+
+    @staticmethod
+    def __remove_backslash_line_continuation_chars(
+        line: Line, string_idx: int
+    ) -> STResult[Line]:
+        """Merge strings that were split across multiple lines using backslashes."""
+        string_leaf = line.leaves[string_idx]
+        if not (
+            string_leaf.type == token.STRING
+            and "\\\n" in string_leaf.value
+            and string_leaf.value.lstrip(STRING_PREFIX_CHARS)[:3] not in {'"""', "'''"}
+        ):
+            return STError(
+                f"String leaf {string_leaf} does not contain any backslash line"
+                " continuation characters."
+            )
+
+        new_line = line.clone()
+        new_line.comments = line.comments
+        append_leaves(new_line, line, line.leaves)
+
+        new_string_leaf = new_line.leaves[string_idx]
+        new_string_leaf.value = new_string_leaf.value.replace("\\\n", "")
+
+        return new_line
+
+    def __merge_first_string_group(self, line: Line, string_idx: int) -> STResult[Line]:
+        vresult = self.__validate_mfsg(line, string_idx)
+        if isinstance(vresult, STError):
+            return vresult
+
+        atom_node = line.leaves[string_idx].parent
+        string_value = ""
+        prefix = ""
+
+        BREAK_MARK = "@@@@@ BLACK BREAKPOINT MARKER @@@@@"
+
+        next_str_idx = string_idx
+        QUOTE = line.leaves[next_str_idx].value[-1]
+        num_of_strings = 0
+        custom_splits = []
+        prefix_tracker = []
+        while (
+            len(line.leaves) > next_str_idx
+            and line.leaves[next_str_idx].type == token.STRING
+        ):
+            num_of_strings += 1
+
+            next_string_value = line.leaves[next_str_idx].value
+
+            naked_string_value = string_value[len(prefix) + 1 : -1]
+            naked_string_value = re.sub(
+                r"([^\\])" + QUOTE, r"\1\\" + QUOTE, naked_string_value
+            )
+
+            next_prefix = get_string_prefix(next_string_value)
+            if not prefix:
+                prefix = next_prefix
+            has_prefix = next_prefix != ""
+            prefix_tracker.append(has_prefix)
+
+            naked_next_string_value = next_string_value[len(next_prefix) + 1 : -1]
+            naked_next_string_value = re.sub(
+                r"([^\\])" + QUOTE, r"\1\\" + QUOTE, naked_next_string_value
+            )
+
+            string_value = (
+                prefix
+                + QUOTE
+                + naked_string_value
+                + naked_next_string_value
+                + BREAK_MARK
+                + QUOTE
+            )
+            next_str_idx += 1
+
+        temp_string_leaf = Leaf(token.STRING, string_value)
+        if self.normalize_strings:
+            normalize_string_quotes(temp_string_leaf)
+
+        naked_string_value = temp_string_leaf.value[len(prefix) + 1 : -1]
+        for has_prefix in prefix_tracker:
+            found_idx = naked_string_value.find(BREAK_MARK)
+            assert (
+                found_idx >= 0
+            ), "Logic error while filling the custom string breakpoint cache."
+
+            naked_string_value = naked_string_value[found_idx + len(BREAK_MARK) :]
+            breakpoint_idx = found_idx + (len(prefix) if has_prefix else 0) + 1
+            custom_splits.append(CustomSplit(has_prefix, breakpoint_idx))
+
+        string_leaf = Leaf(token.STRING, temp_string_leaf.value.replace(BREAK_MARK, ""))
+
+        if atom_node is not None:
+            replace_child(atom_node, string_leaf)
+
+        old_comments = line.comments
+        new_comments = {}
+
+        new_line = line.clone()
+
+        for i, old_leaf in enumerate(line.leaves):
+            if i == string_idx:
+                new_line.append(string_leaf)
+
+            if string_idx <= i < string_idx + num_of_strings:
+                if id(old_leaf) in old_comments:
+                    new_comments[id(string_leaf)] = old_comments[id(old_leaf)]
+                continue
+
+            new_leaf = Leaf(old_leaf.type, old_leaf.value)
+
+            if id(old_leaf) in old_comments:
+                new_comments[id(new_leaf)] = old_comments[id(old_leaf)]
+
+            replace_child(old_leaf, new_leaf)
+            new_line.append(new_leaf)
+
+        new_line.comments = new_comments
+
+        CUSTOM_SPLITS[id(string_leaf.value)] = tuple(custom_splits)
+
+        return new_line
+
+    @staticmethod
+    def __validate_mfsg(line: Line, string_idx: int) -> STResult[None]:
+        num_of_inline_string_comments = 0
+        set_of_prefixes = set()
+        for leaf in line.leaves[string_idx:]:
+            if leaf.type != token.STRING:
+                break
+
+            prefix = get_string_prefix(leaf.value)
+            set_of_prefixes.add(prefix)
+
+            if id(leaf) in line.comments:
+                num_of_inline_string_comments += 1
+
+            if leaf.value.lstrip(STRING_PREFIX_CHARS).startswith(("'''", '"""')):
+                return STError(
+                    "One of the strings that we were attempting to merge was a"
+                    f" multi-line string ({leaf.value}). StringMerger does NOT merge"
+                    " multi-line strings."
+                )
+
+        if num_of_inline_string_comments > 1:
+            return STError(
+                f"Too many inline string comments ({num_of_inline_string_comments})."
+            )
+
+        if len(set_of_prefixes) > 1 and set_of_prefixes != {"", "f"}:
+            return STError(f"Too many different prefixes ({set_of_prefixes}).")
+
+        return None
+
+
+class StringArgCommaStripper(StringTransformerMixin):
+    def _do_match(self, line: Line) -> STMatchResult:
+        return self._regex_match(
+            line, r"^.*?[A-Za-z0-9_]+\(" + STRING_GROUP_REGEXP + r",\).*$"
+        )
+
+    def _do_transform(self, line: Line, string_idx: int) -> Iterator[STResult[Line]]:
+        comma_idx = string_idx + 1
+        comma_leaf = line.leaves[comma_idx]
+
+        new_line = line.clone()
+        new_line.comments = line.comments.copy()
+
+        for i, old_leaf in enumerate(line.leaves):
+            if i == comma_idx:
+                continue
+
+            new_leaf = Leaf(old_leaf.type, old_leaf.value)
+            replace_child(old_leaf, new_leaf)
+            new_line.append(new_leaf)
+
+            if new_leaf.type == token.STRING and id(comma_leaf) in new_line.comments:
+                new_line.comments[id(new_leaf)] = new_line.comments[
+                    id(comma_leaf)
+                ].copy()
+                del new_line.comments[id(comma_leaf)]
+
+        yield new_line
+
+
+class StringParensStripper(StringTransformerMixin):
+    def _do_match(self, line: Line) -> STMatchResult:
+        return self._regex_match(
+            line,
+            r"^.*?" + r"[^A-z0-9_'\"] *\(" + STRING_GROUP_REGEXP + r"\)(?:[^\.].*)?$",
+        )
+
+    def _do_transform(self, line: Line, string_idx: int) -> Iterator[STResult[Line]]:
+        if (
+            id(line.leaves[string_idx - 1]) in line.comments
+            and id(line.leaves[string_idx + 1]) in line.comments
+        ):
+            yield STError(
+                "Cannot strip parens from string when both parens have inline comments."
+            )
+            return
+
+        new_line = line.clone()
+        new_line.comments = line.comments.copy()
+
+        append_leaves(new_line, line, line.leaves[: string_idx - 1])
+
+        string_leaf = Leaf(token.STRING, line.leaves[string_idx].value)
+        replace_child(line.leaves[string_idx - 1], string_leaf)
+        new_line.append(string_leaf)
+
+        for leaf in [line.leaves[string_idx - 1], line.leaves[string_idx + 1]]:
+            if id(leaf) in new_line.comments:
+                new_line.comments[id(string_leaf)] = new_line.comments[id(leaf)].copy()
+                del new_line.comments[id(leaf)]
+
+        append_leaves(new_line, line, line.leaves[string_idx + 2 :])
+
+        yield new_line
+
+
+class StringSplitterMixin(StringTransformerMixin):
+    STRING_CHILD_IDX_MAP: ClassVar[Dict[int, Optional[int]]] = {}
+
+    @abstractmethod
+    def _do_splitter_match(self, line: Line) -> STMatchResult:
+        pass
+
+    @abstractmethod
+    def _do_transform(self, line: Line, string_idx: int) -> Iterator[STResult[Line]]:
+        pass
+
+    def _do_match(self, line: Line) -> STMatchResult:
+        result = self._do_splitter_match(line)
+        if isinstance(result, STError):
+            return result
+
+        idx_result = self._get_string_idx(line.leaves, result)
+        if isinstance(idx_result, ValueError):
+            raise RuntimeError(
+                f"Logic error in `{self.__class__.__name__}._do_splitter_match` method."
+            ) from idx_result
+
+        string_idx = idx_result
+        vresult = self.__validate(line, string_idx)
+        if isinstance(vresult, STError):
+            return vresult
+
+        return result
+
+    @staticmethod
+    def _insert_str_child_factory(string_leaf: Leaf) -> Callable[[LN], None]:
+        string_parent = string_leaf.parent
+
+        child_idx = None
+        if string_parent:
+            child_idx = string_leaf.remove()
+            StringSplitterMixin.STRING_CHILD_IDX_MAP[id(string_leaf)] = child_idx
+            if child_idx is None:
+                raise RuntimeError(
+                    f"Something is wrong here. If {string_parent} is the parent of "
+                    f"{string_leaf}, then how is {string_leaf} not a child of "
+                    f"{string_parent}?"
+                )
+
+        def insert_str_child(child: LN) -> None:
+            child_idx = StringSplitterMixin.STRING_CHILD_IDX_MAP.get(
+                id(string_leaf), None
+            )
+            if string_parent and child_idx is not None:
+                string_parent.insert_child(child_idx, child)
+                StringSplitterMixin.STRING_CHILD_IDX_MAP[id(string_leaf)] = (
+                    child_idx + 1
+                )
+
+        return insert_str_child
+
+    def __validate(self, line: Line, string_idx: int) -> STResult[None]:
+        if is_line_short_enough(line, line_length=self.line_length):
+            return STError("Line is already short enough. No reason to split.")
+
+        string_leaf = line.leaves[string_idx]
+
+        # We set `offset` initially to 3 since, in the worst case, we may have
+        # a line such as: `), <STRING>`
+        #
+        # Hence, we choose to make `offset == len('), ')`.
+        offset = 3
+
+        next_node = string_leaf.next_sibling
+        if (
+            next_node is not None
+            and next_node.type == syms.trailer
+            and [leaf.type for leaf in next_node.leaves()] == [token.DOT, token.NAME]
+            and len(line.leaves) > string_idx + 3
+            and line.leaves[string_idx + 3].type == token.LPAR
+        ):
+            offset += 2
+
+            name_leaf = line.leaves[string_idx + 2]
+            assert name_leaf.type == token.NAME
+            offset += len(name_leaf.value)
+
+        max_line_length = self.line_length - (line.depth * 4) - offset
+        if len(string_leaf.value) <= max_line_length:
+            return STError(
+                "The string itself is not what is causing this line to be too long."
+            )
+
+        if not string_leaf.parent or [L.type for L in string_leaf.parent.children] == [
+            token.STRING,
+            token.NEWLINE,
+        ]:
+            return STError(
+                f"This string ({string_leaf.value}) appears to be pointless (i.e. has"
+                " no parent)."
+            )
+
+        if (
+            line.comments
+            and list(line.comments.values())[0]
+            and re.match(
+                r"^#\s*([a-z_0-9]+:.*|noqa)\s*$",
+                list(line.comments.values())[0][0].value,
+                re.IGNORECASE,
+            )
+        ):
+            return STError(
+                "Line appears to end with an inline pragma comment. Splitting the line "
+                "could modify the pragma's behavior."
+            )
+
+        return None
+
+
+class StringTermSplitter(StringSplitterMixin):
+    def _do_splitter_match(self, line: Line) -> STMatchResult:
+        return self._regex_match(
+            line,
+            r"^ *(?:\+ *)?"
+            + STRING_GROUP_REGEXP
+            + STRING_DOT_OR_PERC_REGEXP
+            + STRING_END_COMMENT_REGEXP
+            + "$",
+        )
+
+    def _do_transform(self, line: Line, string_idx: int) -> Iterator[STResult[Line]]:
+        insert_str_child = self._insert_str_child_factory(line.leaves[string_idx])
+
+        rest_value = line.leaves[string_idx].value
+        prefix = get_string_prefix(rest_value)
+
+        rest_line = line.clone()
+        rest_leaf = Leaf(token.STRING, rest_value)
+        rest_line.append(rest_leaf)
+
+        max_rest_length = self.line_length - len(prefix)
+        max_next_length = self.line_length - (1 + len(prefix)) - (line.depth * 4)
+        if max_next_length < 0:
+            yield STError(
+                f"Unable to split {line.leaves[string_idx].value} at such high of a"
+                f" line depth: {line.depth}"
+            )
+            return
+
+        QUOTE = rest_value[-1]
+
+        custom_splits = list(CUSTOM_SPLITS[id(line.leaves[string_idx].value)])
+
+        starts_with_plus = line.leaves[0].type == token.PLUS
+        drop_pointless_f_prefix = ("f" not in prefix) or re.search(
+            r"\{.+\}", rest_value
+        )
+        use_custom_breakpoints = bool(
+            custom_splits
+            and all(csplit.break_idx <= max_next_length for csplit in custom_splits)
+        )
+
+        first_string_line = True
+        while len(line_to_string(rest_line)) > max_rest_length or (
+            len(custom_splits) > 1 and use_custom_breakpoints
+        ):
+            prepend_plus = first_string_line and starts_with_plus
+
+            if use_custom_breakpoints:
+                csplit = custom_splits.pop(0)
+                if not csplit.has_prefix and prefix not in ["", "f"]:
+                    rest_value = rest_value.lstrip(prefix)
+
+                idx = csplit.break_idx
+            else:
+                max_length = max_next_length - 2 if prepend_plus else max_next_length
+                idx_result = self.__get_break_idx(rest_value, max_length)
+                if isinstance(idx_result, STError):
+                    yield idx_result
+                    return
+
+                idx = idx_result
+
+            next_value = rest_value[:idx] + QUOTE
+
+            if (
+                next_value != self.__normalize_f_string(next_value, prefix)
+                and drop_pointless_f_prefix
+            ):
+                if use_custom_breakpoints:
+                    idx += 1
+                    next_value = rest_value[:idx] + QUOTE
+                next_value = self.__normalize_f_string(next_value, prefix)
+
+            next_line = line.clone()
+
+            if prepend_plus:
+                plus_leaf = Leaf(token.PLUS, "+")
+                replace_child(line.leaves[0], plus_leaf)
+                next_line.append(plus_leaf)
+
+            next_leaf = Leaf(token.STRING, next_value)
+            insert_str_child(next_leaf)
+            next_line.append(next_leaf)
+
+            if self.normalize_strings:
+                normalize_string_quotes(next_leaf)
+
+            yield next_line
+
+            rest_value = prefix + QUOTE + rest_value[idx:]
+            if drop_pointless_f_prefix:
+                rest_value = self.__normalize_f_string(rest_value, prefix)
+
+            rest_line = line.clone()
+            rest_leaf = Leaf(token.STRING, rest_value)
+            rest_line.append(rest_leaf)
+
+            first_string_line = False
+
+        if use_custom_breakpoints:
+            csplit = custom_splits.pop(0)
+            if not csplit.has_prefix and prefix not in ["", "f"]:
+                rest_leaf.value = rest_leaf.value.lstrip(prefix)
+
+        if self.normalize_strings:
+            normalize_string_quotes(rest_leaf)
+
+        insert_str_child(rest_leaf)
+
+        if len(line.leaves) > (string_idx + 1):
+            non_string_line = rest_line.clone()
+            append_leaves(non_string_line, line, line.leaves[string_idx + 1 :])
+
+            if (
+                len(line_to_string(rest_line))
+                + len(line_to_string(non_string_line))
+                - non_string_line.depth * 4
+            ) <= self.line_length:
+                last_line = line.clone()
+
+                append_leaves(
+                    last_line, line, rest_line.leaves + non_string_line.leaves
+                )
+
+                yield last_line
+            else:
+                yield rest_line
+                yield non_string_line
+        else:
+            rest_line.comments = line.comments
+            yield rest_line
+
+        del CUSTOM_SPLITS[id(line.leaves[string_idx].value)]
+
+    @staticmethod
+    def __get_break_idx(string_value: str, max_length: int) -> STResult[int]:
+        assert max_length > 0
+
+        idx = max_length
+        while 0 < idx + 1 < len(string_value) and string_value[idx] != " ":
+            idx -= 1
+
+        if string_value[idx] != " ":
+            # This line is going to be longer than the specified line length, but
+            # let's try to split it anyway.
+            idx = max_length + 1
+            while idx + 1 < len(string_value) and string_value[idx] != " ":
+                idx += 1
+            if string_value[idx] != " ":
+                return STError("Long strings which contain no spaces are not split.")
+
+        return idx
+
+    @staticmethod
+    def __normalize_f_string(string: str, prefix: str) -> str:
+        if "f" in prefix and not re.search(r"\{.+\}", string):
+            return prefix.replace("f", "") + string[len(prefix) :]
+        else:
+            return string
+
+
+class StringExprSplitterMixin(StringSplitterMixin):
+    @abstractmethod
+    def _do_splitter_match(self, line: Line) -> STMatchResult:
+        pass
+
+    def _do_transform(self, line: Line, string_idx: int) -> Iterator[STResult[Line]]:
+        insert_str_child = self._insert_str_child_factory(line.leaves[string_idx])
+
+        comma_idx = len(line.leaves) - 1
+        ends_with_comma = False
+        if line.leaves[comma_idx].type == token.COMMA:
+            ends_with_comma = True
+
+        first_line = line.clone()
+        first_line.comments = line.comments
+        left_leaves = line.leaves[:string_idx]
+        old_parens_exist = False
+        if left_leaves and left_leaves[-1].type == token.LPAR:
+            old_parens_exist = True
+            left_leaves.pop()
+
+        append_leaves(first_line, line, left_leaves)
+
+        lpar_leaf = Leaf(token.LPAR, "(")
+        if old_parens_exist:
+            replace_child(line.leaves[string_idx - 1], lpar_leaf)
+        else:
+            insert_str_child(lpar_leaf)
+        first_line.append(lpar_leaf)
+
+        yield first_line
+
+        # Only need to yield one (possibly too long) line, since the
+        # `StringTermSplitter` will break it down further if necessary.
+        string_value = line.leaves[string_idx].value
+        string_line = Line(
+            depth=line.depth + 1,
+            inside_brackets=True,
+            should_explode=line.should_explode,
+        )
+        string_leaf = Leaf(token.STRING, string_value)
+        insert_str_child(string_leaf)
+        string_line.append(string_leaf)
+
+        old_rpar_leaf = None
+        if len(line.leaves) > string_idx + 1:
+            right_leaves = line.leaves[string_idx + 1 :]
+            if ends_with_comma:
+                right_leaves.pop()
+
+            if old_parens_exist:
+                assert (
+                    right_leaves and right_leaves[-1].type == token.RPAR
+                ), "Apparently, old parenthesis do NOT exist?!"
+                old_rpar_leaf = right_leaves.pop()
+
+            append_leaves(string_line, line, right_leaves)
+
+        yield string_line
+
+        last_line = line.clone()
+        new_rpar_leaf = Leaf(token.RPAR, ")")
+        if old_rpar_leaf is not None:
+            replace_child(old_rpar_leaf, new_rpar_leaf)
+        else:
+            insert_str_child(new_rpar_leaf)
+        last_line.append(new_rpar_leaf)
+
+        if ends_with_comma:
+            comma_leaf = Leaf(token.COMMA, ",")
+            replace_child(line.leaves[comma_idx], comma_leaf)
+            last_line.append(comma_leaf)
+
+        yield last_line
+
+
+class StringExprSplitter(StringExprSplitterMixin):
+    def _do_splitter_match(self, line: Line) -> STMatchResult:
+        regex_result = self._regex_match(
+            line,
+            r"^ *(?:return |else |assert .*, ?|[A-Za-z0-9\._]*?"
+            + r" ?\+?= ?)?"
+            + STRING_GROUP_REGEXP
+            + STRING_DOT_OR_PERC_REGEXP
+            + ",?"
+            + STRING_END_COMMENT_REGEXP
+            + "$",
+        )
+
+        if isinstance(regex_result, str):
+            return regex_result
+
+        dict_regex_result = self._regex_match(
+            line,
+            r"^ *(?:[^'\":{}]|"
+            + STRING_REGEXP
+            + ")*?: *"
+            + STRING_GROUP_REGEXP
+            + STRING_DOT_OR_PERC_REGEXP
+            + ",?"
+            + STRING_END_COMMENT_REGEXP
+            + "$",
+        )
+
+        if isinstance(dict_regex_result, STError):
+            dict_regex_result.__cause__ = regex_result
+            return dict_regex_result
+
+        idx_result = self._get_string_idx(line.leaves, dict_regex_result)
+        bad_dict_match_error = STError(
+            f"Bad dictionary regular expression match: ({dict_regex_result})"
+        )
+        if isinstance(idx_result, ValueError):
+            idx_result.__cause__ = regex_result
+            bad_dict_match_error.__cause__ = idx_result
+            return bad_dict_match_error
+
+        string_idx = idx_result
+        node = line.leaves[string_idx].parent
+        while node is not None:
+            if node.type == syms.dictsetmaker:
+                return dict_regex_result
+
+            if node.type not in [syms.power, syms.term, syms.atom]:
+                break
+
+            node = node.parent
+
+        bad_dict_match_error.__cause__ = regex_result
+        return bad_dict_match_error
+
+
+class StringArithExprSplitter(StringExprSplitterMixin):
+    def _do_splitter_match(self, line: Line) -> STMatchResult:
+        return self._regex_match(
+            line,
+            "^ *"
+            + STRING_GROUP_REGEXP
+            + STRING_DOT_OR_PERC_REGEXP
+            + r" ?\+ .+,"
+            + STRING_END_COMMENT_REGEXP
+            + "$",
+        )
+
+
+def line_to_string(line: Line) -> str:
+    return str(line).strip("\n")
+
+
+def append_leaves(new_line: Line, old_line: Line, leaves: List[Leaf]) -> None:
+    for old_leaf in leaves:
+        new_leaf = Leaf(old_leaf.type, old_leaf.value)
+        replace_child(old_leaf, new_leaf)
+        new_line.append(new_leaf)
+
+        for comment_leaf in old_line.comments_after(old_leaf):
+            new_line.append(comment_leaf, preformatted=True)
+
+
+def replace_child(old_child: LN, new_child: LN) -> None:
+    parent = old_child.parent
+    if not parent:
+        return
+
+    child_idx = old_child.remove()
+    if child_idx is not None:
+        parent.insert_child(child_idx, new_child)
+
+
+def get_string_prefix(string: str) -> str:
+    prefix = ""
+    prefix_idx = 0
+    while string[prefix_idx] in STRING_PREFIX_CHARS:
+        prefix += string[prefix_idx].lower()
+        prefix_idx += 1
+
+    return prefix
+
+
+def left_hand_split(line: Line, _features: Collection[Feature] = ()) -> Iterator[Line]:
     """Split line into many lines, starting with the first matching bracket pair.
 
     Note: this usually looks weird, only use this for function definitions.
@@ -2589,8 +3464,7 @@ def right_hand_split(
                 raise CannotSplit(
                     "The current optional pair of parentheses is bound to fail to "
                     "satisfy the splitting algorithm because the head or the tail "
-                    "contains multiline strings which by definition never fit one "
-                    "line."
+                    "contains multiline strings which by definition never fit one line."
                 )
 
     ensure_visible(opening_bracket)
@@ -2621,8 +3495,8 @@ def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None
 
         elif tail_len < 3:
             raise CannotSplit(
-                f"Splitting brackets on an empty body to save "
-                f"{tail_len} characters is not worth it"
+                f"Splitting brackets on an empty body to save {tail_len} characters "
+                "is not worth it"
             )
 
 
@@ -2831,7 +3705,7 @@ def normalize_string_prefix(leaf: Leaf, remove_u_prefix: bool = False) -> None:
 
     Note: Mutates its argument.
     """
-    match = re.match(r"^([furbFURB]*)(.*)$", leaf.value, re.DOTALL)
+    match = re.match(r"^([" + STRING_PREFIX_CHARS + r"]*)(.*)$", leaf.value, re.DOTALL)
     assert match is not None, f"failed to match string {leaf.value!r}"
     orig_prefix = match.group(1)
     new_prefix = orig_prefix.lower()
@@ -2848,7 +3722,7 @@ def normalize_string_quotes(leaf: Leaf) -> None:
 
     Note: Mutates its argument.
     """
-    value = leaf.value.lstrip("furbFURB")
+    value = leaf.value.lstrip(STRING_PREFIX_CHARS)
     if value[:3] == '"""':
         return
 
@@ -3258,7 +4132,7 @@ def is_vararg(leaf: Leaf, within: Set[NodeType]) -> bool:
 
 def is_multiline_string(leaf: Leaf) -> bool:
     """Return True if `leaf` is a multiline string that actually spans many lines."""
-    value = leaf.value.lstrip("furbFURB")
+    value = leaf.value.lstrip(STRING_PREFIX_CHARS)
     return value[:3] in {'"""', "'''"} and "\n" in value
 
 
@@ -3778,8 +4652,8 @@ def assert_equivalent(src: str, dst: str) -> None:
         src_ast = parse_ast(src)
     except Exception as exc:
         raise AssertionError(
-            f"cannot use --safe with this file; failed to parse source file.  "
-            f"AST error message: {exc}"
+            "cannot use --safe with this file; failed to parse source file.  AST "
+            f"error message: {exc}"
         )
 
     try:
@@ -3787,9 +4661,9 @@ def assert_equivalent(src: str, dst: str) -> None:
     except Exception as exc:
         log = dump_to_file("".join(traceback.format_tb(exc.__traceback__)), dst)
         raise AssertionError(
-            f"INTERNAL ERROR: Black produced invalid code: {exc}. "
-            f"Please report a bug on https://github.com/psf/black/issues.  "
-            f"This invalid output might be helpful: {log}"
+            f"INTERNAL ERROR: Black produced invalid code: {exc}. Please report a bug "
+            "on https://github.com/psf/black/issues.  This invalid output might be "
+            f"helpful: {log}"
         ) from None
 
     src_ast_str = "\n".join(_v(src_ast))
@@ -3797,9 +4671,8 @@ def assert_equivalent(src: str, dst: str) -> None:
     if src_ast_str != dst_ast_str:
         log = dump_to_file(diff(src_ast_str, dst_ast_str, "src", "dst"))
         raise AssertionError(
-            f"INTERNAL ERROR: Black produced code that is not equivalent to "
-            f"the source.  "
-            f"Please report a bug on https://github.com/psf/black/issues.  "
+            "INTERNAL ERROR: Black produced code that is not equivalent to the "
+            "source.  Please report a bug on https://github.com/psf/black/issues.  "
             f"This diff might be helpful: {log}"
         ) from None
 
@@ -3813,10 +4686,9 @@ def assert_stable(src: str, dst: str, mode: FileMode) -> None:
             diff(dst, newdst, "first pass", "second pass"),
         )
         raise AssertionError(
-            f"INTERNAL ERROR: Black produced different code on the second pass "
-            f"of the formatter.  "
-            f"Please report a bug on https://github.com/psf/black/issues.  "
-            f"This diff might be helpful: {log}"
+            "INTERNAL ERROR: Black produced different code on the second pass of the "
+            "formatter.  Please report a bug on https://github.com/psf/black/issues. "
+            f" This diff might be helpful: {log}"
         ) from None
 
 
@@ -3942,7 +4814,7 @@ def is_line_short_enough(line: Line, *, line_length: int, line_str: str = "") ->
     Uses the provided `line_str` rendering, if any, otherwise computes a new one.
     """
     if not line_str:
-        line_str = str(line).strip("\n")
+        line_str = line_to_string(line)
     return (
         len(line_str) <= line_length
         and "\n" not in line_str  # multiline strings
diff --git a/blib2to3/pgen2/pgen.py b/blib2to3/pgen2/pgen.py
index 774cffc..33592e3 100644
--- a/blib2to3/pgen2/pgen.py
+++ b/blib2to3/pgen2/pgen.py
@@ -167,8 +167,8 @@ class ParserGenerator(object):
             for symbol in itsfirst:
                 if symbol in inverse:
                     raise ValueError(
-                        "rule %s is ambiguous; %s is in the"
-                        " first sets of %s as well as %s"
+                        "rule %s is ambiguous; %s is in the first sets of %s as well "
+                        "as %s"
                         % (name, symbol, label, inverse[symbol])
                     )
                 inverse[symbol] = label
diff --git a/tests/data/cantfit.py b/tests/data/cantfit.py
index 317a38f..cbc26f9 100644
--- a/tests/data/cantfit.py
+++ b/tests/data/cantfit.py
@@ -35,7 +35,7 @@ for key in """
 """.split():
     if key in self.connect_kwargs:
         raise ValueError(err.format(key))
-concatenated_strings = "some strings that are" "concatenated implicitly, so if you put them on separate" "lines it will fit"
+concatenated_strings = "some strings that are " "concatenated implicitly, so if you put them on separate " "lines it will fit"
 del concatenated_strings, string_variable_name, normal_function_name, normal_name, need_more_to_make_the_line_long_enough
 
 
@@ -75,8 +75,14 @@ normal_name = but_the_function_name_is_now_ridiculously_long_and_it_is_still_sup
 )
 # long arguments
 normal_name = normal_function_name(
-    "but with super long string arguments that on their own exceed the line limit so there's no way it can ever fit",
-    "eggs with spam and eggs and spam with eggs with spam and eggs and spam with eggs with spam and eggs and spam with eggs",
+    (
+        "but with super long string arguments that on their own exceed the line limit"
+        " so there's no way it can ever fit"
+    ),
+    (
+        "eggs with spam and eggs and spam with eggs with spam and eggs and spam with"
+        " eggs with spam and eggs and spam with eggs"
+    ),
     this_is_a_ridiculously_long_name_and_nobody_in_their_right_mind_would_use_one_like_it=0,
 )
 string_variable_name = "a string that is waaaaaaaayyyyyyyy too long, even in parens, there's nothing you can do"  # noqa
@@ -88,8 +94,8 @@ for key in """
     if key in self.connect_kwargs:
         raise ValueError(err.format(key))
 concatenated_strings = (
-    "some strings that are"
-    "concatenated implicitly, so if you put them on separate"
+    "some strings that are "
+    "concatenated implicitly, so if you put them on separate "
     "lines it will fit"
 )
 del (
diff --git a/tests/data/comments4.py b/tests/data/comments4.py
index c0db5b1..acd020d 100644
--- a/tests/data/comments4.py
+++ b/tests/data/comments4.py
@@ -13,49 +13,54 @@ class C:
             # metadata_version errors.
             (
                 {},
-                "None is an invalid value for Metadata-Version. "
-                "Error: This field is required. "
-                "see "
-                "https://packaging.python.org/specifications/core-metadata",
+                (
+                    "None is an invalid value for Metadata-Version. Error: This field "
+                    "is required. see "
+                    "https://packaging.python.org/specifications/core-metadata"
+                ),
             ),
             (
                 {"metadata_version": "-1"},
-                "'-1' is an invalid value for Metadata-Version. "
-                "Error: Unknown Metadata Version "
-                "see "
-                "https://packaging.python.org/specifications/core-metadata",
+                (
+                    "'-1' is an invalid value for Metadata-Version. Error: Unknown "
+                    "Metadata Version see "
+                    "https://packaging.python.org/specifications/core-metadata"
+                ),
             ),
             # name errors.
             (
                 {"metadata_version": "1.2"},
-                "'' is an invalid value for Name. "
-                "Error: This field is required. "
-                "see "
-                "https://packaging.python.org/specifications/core-metadata",
+                (
+                    "'' is an invalid value for Name. Error: This field is required. "
+                    "see https://packaging.python.org/specifications/core-metadata"
+                ),
             ),
             (
                 {"metadata_version": "1.2", "name": "foo-"},
-                "'foo-' is an invalid value for Name. "
-                "Error: Must start and end with a letter or numeral and "
-                "contain only ascii numeric and '.', '_' and '-'. "
-                "see "
-                "https://packaging.python.org/specifications/core-metadata",
+                (
+                    "'foo-' is an invalid value for Name. Error: Must start and end "
+                    "with a letter or numeral and contain only ascii numeric and '.', "
+                    "'_' and '-'. see "
+                    "https://packaging.python.org/specifications/core-metadata"
+                ),
             ),
             # version errors.
             (
                 {"metadata_version": "1.2", "name": "example"},
-                "'' is an invalid value for Version. "
-                "Error: This field is required. "
-                "see "
-                "https://packaging.python.org/specifications/core-metadata",
+                (
+                    "'' is an invalid value for Version. Error: This field is "
+                    "required. see "
+                    "https://packaging.python.org/specifications/core-metadata"
+                ),
             ),
             (
                 {"metadata_version": "1.2", "name": "example", "version": "dog"},
-                "'dog' is an invalid value for Version. "
-                "Error: Must start and end with a letter or numeral and "
-                "contain only ascii numeric and '.', '_' and '-'. "
-                "see "
-                "https://packaging.python.org/specifications/core-metadata",
+                (
+                    "'dog' is an invalid value for Version. Error: Must start and end "
+                    "with a letter or numeral and contain only ascii numeric and '.', "
+                    "'_' and '-'. see "
+                    "https://packaging.python.org/specifications/core-metadata"
+                ),
             ),
         ],
     )
diff --git a/tests/data/comments6.py b/tests/data/comments6.py
index abfd96e..735c6aa 100644
--- a/tests/data/comments6.py
+++ b/tests/data/comments6.py
@@ -104,7 +104,9 @@ def func(
     )
 
 
-result = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"  # aaa
+result = (  # aaa
+    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
+)
 
 AAAAAAAAAAAAA = [AAAAAAAAAAAAA] + SHARED_AAAAAAAAAAAAA + USER_AAAAAAAAAAAAA + AAAAAAAAAAAAA  # type: ignore
 
diff --git a/tests/data/composition.py b/tests/data/composition.py
index ac63e46..d804d5a 100644
--- a/tests/data/composition.py
+++ b/tests/data/composition.py
@@ -10,13 +10,17 @@ class C:
             )
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 1 file left unchanged, "
-                "1 file failed to reformat.",
+                (
+                    "2 files reformatted, 1 file left unchanged, 1 file failed to "
+                    "reformat."
+                ),
             )
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "2 files failed to reformat.",
+                (
+                    "2 files reformatted, 2 files left unchanged, 2 files failed to "
+                    "reformat."
+                ),
             )
             for i in (a,):
                 if (
@@ -40,8 +44,7 @@ class C:
             items=items[:num_items]
         )
         return (
-            "Utterly failed doctest test for %s\n"
-            '  File "%s", line %s, in %s\n\n%s'
+            'Utterly failed doctest test for %s\n   File "%s", line %s, in %s\n\n%s'
             % (test.name, test.filename, lineno, lname, err)
         )
 
@@ -150,8 +153,8 @@ class C:
             key8: value8,
             key9: value9,
         }, (
-            "Not what we expected and the message is too long to fit "
-            "in one line because it's too long"
+            "Not what we expected and the message is too long to fit in one line "
+            "because it's too long"
         )
 
         dis_c_instance_method = """\
diff --git a/tests/data/long_strings.py b/tests/data/long_strings.py
new file mode 100644
index 0000000..7aa0aaf
--- /dev/null
+++ b/tests/data/long_strings.py
@@ -0,0 +1,641 @@
+x = "This is a really long string that can't possibly be expected to fit all together on one line. In fact it may even take up three or more lines... like four or five... but probably just three."
+
+x += "This is a really long string that can't possibly be expected to fit all together on one line. In fact it may even take up three or more lines... like four or five... but probably just three."
+
+y = (
+    "Short string"
+)
+
+print("This is a really long string inside of a print statement with extra arguments attached at the end of it.", x, y, z)
+
+print("This is a really long string inside of a print statement with no extra arguments attached at the end of it.")
+
+D1 = {"The First": "This is a really long string that can't possibly be expected to fit all together on one line. Also it is inside a dictionary, so formatting is more difficult.", "The Second": "This is another really really (not really) long string that also can't be expected to fit on one line and is, like the other string, inside a dictionary."}
+
+D2 = {1.0: "This is a really long string that can't possibly be expected to fit all together on one line. Also it is inside a dictionary, so formatting is more difficult.", 2.0: "This is another really really (not really) long string that also can't be expected to fit on one line and is, like the other string, inside a dictionary."}
+
+D3 = {x: "This is a really long string that can't possibly be expected to fit all together on one line. Also it is inside a dictionary, so formatting is more difficult.", y: "This is another really really (not really) long string that also can't be expected to fit on one line and is, like the other string, inside a dictionary."}
+
+D4 = {"A long and ridiculous {}".format(string_key): "This is a really really really long string that has to go i,side of a dictionary. It is soooo bad.", some_func("calling", "some", "stuff"): "This is a really really really long string that has to go inside of a dictionary. It is {soooo} bad (#{x}).".format(sooo="soooo", x=2), "A %s %s" % ("formatted", "string"): "This is a really really really long string that has to go inside of a dictionary. It is %s bad (#%d)." % ("soooo", 2)}
+
+func_with_keywords(my_arg, my_kwarg="Long keyword strings also need to be wrapped, but they will probably need to be handled a little bit differently.")
+
+bad_split1 = (
+    "But what should happen when code has already been formatted but in the wrong way? Like"
+    " with a space at the beginning instead of the end. Or what about when it is split too soon?"
+)
+
+bad_split2 = "But what should happen when code has already " \
+             "been formatted but in the wrong way? Like " \
+             "with a space at the beginning instead of the " \
+             "end. Or what about when it is split too " \
+             "soon? In the case of a split that is too " \
+             "short, black will try to honer the custom " \
+             "split."
+
+bad_split3 = (
+    "What if we have inline comments on "  # First Comment
+    "each line of a bad split? In that "  # Second Comment
+    "case, we should just leave it alone."  # Third Comment
+)
+
+bad_split_func1(
+    "But what should happen when code has already "
+    "been formatted but in the wrong way? Like "
+    "with a space at the beginning instead of the "
+    "end. Or what about when it is split too "
+    "soon? In the case of a split that is too "
+    "short, black will try to honer the custom "
+    "split.",
+    xxx, yyy, zzz
+)
+
+bad_split_func2(
+    xxx, yyy, zzz,
+    long_string_kwarg="But what should happen when code has already been formatted but in the wrong way? Like "
+                      "with a space at the beginning instead of the end. Or what about when it is split too "
+                      "soon?",
+)
+
+bad_split_func3(
+    (
+        "But what should happen when code has already "
+        r"been formatted but in the wrong way? Like "
+        "with a space at the beginning instead of the "
+        r"end. Or what about when it is split too "
+        r"soon? In the case of a split that is too "
+        "short, black will try to honer the custom "
+        "split."
+    ),
+    xxx,
+    yyy,
+    zzz,
+)
+
+raw_string = r"This is a long raw string. When re-formatting this string, black needs to make sure it prepends the 'r' onto the new string."
+
+fmt_string1 = "We also need to be sure to preserve any and all {} which may or may not be attached to the string in question.".format("method calls")
+
+fmt_string2 = "But what about when the string is {} but {}".format("short", "the method call is really really really really really really really really long?")
+
+old_fmt_string1 = "While we are on the topic of %s, we should also note that old-style formatting must also be preserved, since some %s still uses it." % ("formatting", "code")
+
+old_fmt_string2 = "This is a %s %s %s %s" % ("really really really really really", "old", "way to format strings!", "Use f-strings instead!")
+
+old_fmt_string3 = "Whereas only the strings after the percent sign were long in the last example, this example uses a long initial string as well. This is another %s %s %s %s" % ("really really really really really", "old", "way to format strings!", "Use f-strings instead!")
+
+fstring = f"f-strings definitely make things more {difficult} than they need to be for black. But boy they sure are handy. The problem is that some lines will need to have the 'f' whereas others do not. This {line}, for example, needs one."
+
+comment_string = "Long lines with inline comments should have their comments appended to the reformatted string's enclosing right parentheses."  # This comment gets thrown to the top.
+
+arg_comment_string = print("Long lines with inline comments which are apart of (and not the only member of) an argument list should have their comments appended to the reformatted string's enclosing left parentheses.",  # This comment gets thrown to the top.
+    "Arg #2", "Arg #3", "Arg #4", "Arg #5")
+
+pragma_comment_string1 = "Lines which end with an inline pragma comment of the form `# <pragma>: <...>` should be left alone."  # noqa: E501
+
+pragma_comment_string2 = "Lines which end with an inline pragma comment of the form `# <pragma>: <...>` should be left alone."  # noqa
+
+"""This is a really really really long triple quote string and it should not be touched."""
+
+triple_quote_string = """This is a really really really long triple quote string assignment and it should not be touched."""
+
+# Regression test. There was a bug where tuples were being identified as long strings.
+long_tuple = ('Apple', 'Berry', 'Cherry', 'Dill', 'Evergreen', 'Fig',
+           'Grape', 'Harry', 'Iglu', 'Jaguar')
+
+assert some_type_of_boolean_expression, "Followed by a really really really long string that is used to provide context to the AssertionError exception."
+
+assert some_type_of_boolean_expression, "Followed by a really really really long string that is used to provide context to the AssertionError exception, which uses dynamic string {}.".format("formatting")
+
+assert some_type_of_boolean_expression, "Followed by a really really really long string that is used to provide context to the AssertionError exception, which uses dynamic string %s." % "formatting"
+
+assert some_type_of_boolean_expression, "Followed by a really really really long string that is used to provide context to the AssertionError exception, which uses dynamic %s %s." % ("string", "formatting")
+
+some_function_call("With a reallly generic name and with a really really long string that is, at some point down the line, " + added + " to a variable and then added to another string.")
+
+some_function_call("With a reallly generic name and with a really really long string that is, at some point down the line, " + added + " to a variable and then added to another string. But then what happens when the final string is also supppppperrrrr long?! Well then that second (realllllllly long) string should be split too.", "and a second argument", and_a_third)
+
+return "A really really really really really really really really really really really really really long {} {}".format("return", "value")
+
+func_with_bad_comma(
+    "This is a really long string argument to a function that has a trailing comma which should NOT be there.",
+)
+
+func_with_bad_comma(
+    "This is a really long string argument to a function that has a trailing comma which should NOT be there.", # comment after comma
+)
+
+func_with_bad_comma(
+    (
+        "This is a really long string argument to a function that has a trailing comma"
+        " which should NOT be there."
+    ),
+)
+
+func_with_bad_comma(
+    (
+        "This is a really long string argument to a function that has a trailing comma"
+        " which should NOT be there."
+    ), # comment after comma
+)
+
+func_with_bad_parens(
+    ("short string that should have parens stripped"),
+    x,
+    y,
+    z,
+)
+
+func_with_bad_parens(
+    x,
+    y,
+    ("short string that should have parens stripped"),
+    z,
+)
+
+########## REGRESSION TESTS ##########
+stupid_format_method_bug = "Some really long string that just so happens to be the {} {} to force the 'format' method to hang over the line length boundary. This is pretty annoying.".format("perfect", "length")
+
+class A:
+    def foo():
+        os.system("This is a regression test. xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxxx.".format("xxxxxxxxxx", "xxxxxx", "xxxxxxxxxx"))
+
+
+class A:
+    def foo():
+        XXXXXXXXXXXX.append(
+            (
+                "xxx_xxxxxxxxxx(xxxxx={}, xxxx={}, xxxxx, xxxx_xxxx_xxxxxxxxxx={})".format(
+                    xxxxx, xxxx, xxxx_xxxx_xxxxxxxxxx
+                ),
+                my_var,
+                my_other_var,
+            )
+        )
+
+class A:
+    class B:
+        def foo():
+            bar(
+                (
+                    "[{}]: xxx_xxxxxxxxxx(xxxxx={}, xxxx={}, xxxxx={}"
+                    " xxxx_xxxx_xxxxxxxxxx={}, xxxx={})"
+                    .format(xxxx._xxxxxxxxxxxxxx, xxxxx, xxxx, xxxx_xxxx_xxxxxxxxxx, xxxxxxx)
+                ),
+                varX,
+                varY,
+                varZ,
+            )
+
+def foo(xxxx):
+    for (xxx_xxxx, _xxx_xxx, _xxx_xxxxx, xxx_xxxx) in xxxx:
+        for xxx in xxx_xxxx:
+            assert ("x" in xxx) or (
+                xxx in xxx_xxx_xxxxx
+            ), "{0} xxxxxxx xx {1}, xxx {1} xx xxx xx xxxx xx xxx xxxx: xxx xxxx {2}".format(
+                xxx_xxxx, xxx, xxxxxx.xxxxxxx(xxx_xxx_xxxxx)
+            )
+
+class A:
+    def disappearing_comment():
+        return (
+            (  # xx -x xxxxxxx xx xxx xxxxxxx.
+                '{{xxx_xxxxxxxxxx_xxxxxxxx}} xxx xxxx'
+                ' {} {{xxxx}} >&2'
+                .format(
+                    "{xxxx} {xxxxxx}"
+                    if xxxxx.xx_xxxxxxxxxx
+                    else ( # Disappearing Comment
+                        "--xxxxxxx --xxxxxx=x --xxxxxx-xxxxx=xxxxxx"
+                        " --xxxxxx-xxxx=xxxxxxxxxxx.xxx"
+                    )
+                )
+            ),
+            (x, y, z),
+        )
+
+class A:
+    class B:
+        def foo():
+            xxxxx_xxxx(
+                xx, "\t"
+                "@xxxxxx '{xxxx_xxx}\t' > {xxxxxx_xxxx}.xxxxxxx;"
+                "{xxxx_xxx} >> {xxxxxx_xxxx}.xxxxxxx 2>&1; xx=$$?;"
+                "xxxx $$xx"
+                .format(xxxx_xxx=xxxx_xxxxxxx, xxxxxx_xxxx=xxxxxxx + "/" + xxxx_xxx_xxxx, x=xxx_xxxxx_xxxxx_xxx),
+                x,
+                y,
+                z,
+            )
+
+# output
+
+x = (
+    "This is a really long string that can't possibly be expected to fit all together"
+    " on one line. In fact it may even take up three or more lines... like four or"
+    " five... but probably just three."
+)
+
+x += (
+    "This is a really long string that can't possibly be expected to fit all together"
+    " on one line. In fact it may even take up three or more lines... like four or"
+    " five... but probably just three."
+)
+
+y = "Short string"
+
+print(
+    (
+        "This is a really long string inside of a print statement with extra arguments"
+        " attached at the end of it."
+    ),
+    x,
+    y,
+    z,
+)
+
+print(
+    "This is a really long string inside of a print statement with no extra arguments"
+    " attached at the end of it."
+)
+
+D1 = {
+    "The First": (
+        "This is a really long string that can't possibly be expected to fit all"
+        " together on one line. Also it is inside a dictionary, so formatting is more"
+        " difficult."
+    ),
+    "The Second": (
+        "This is another really really (not really) long string that also can't be"
+        " expected to fit on one line and is, like the other string, inside a"
+        " dictionary."
+    ),
+}
+
+D2 = {
+    1.0: (
+        "This is a really long string that can't possibly be expected to fit all"
+        " together on one line. Also it is inside a dictionary, so formatting is more"
+        " difficult."
+    ),
+    2.0: (
+        "This is another really really (not really) long string that also can't be"
+        " expected to fit on one line and is, like the other string, inside a"
+        " dictionary."
+    ),
+}
+
+D3 = {
+    x: (
+        "This is a really long string that can't possibly be expected to fit all"
+        " together on one line. Also it is inside a dictionary, so formatting is more"
+        " difficult."
+    ),
+    y: (
+        "This is another really really (not really) long string that also can't be"
+        " expected to fit on one line and is, like the other string, inside a"
+        " dictionary."
+    ),
+}
+
+D4 = {
+    "A long and ridiculous {}".format(string_key): (
+        "This is a really really really long string that has to go i,side of a"
+        " dictionary. It is soooo bad."
+    ),
+    some_func("calling", "some", "stuff"): (
+        "This is a really really really long string that has to go inside of a"
+        " dictionary. It is {soooo} bad (#{x}).".format(sooo="soooo", x=2)
+    ),
+    "A %s %s"
+    % ("formatted", "string"): (
+        "This is a really really really long string that has to go inside of a"
+        " dictionary. It is %s bad (#%d)."
+    )
+    % ("soooo", 2),
+}
+
+func_with_keywords(
+    my_arg,
+    my_kwarg=(
+        "Long keyword strings also need to be wrapped, but they will probably need to"
+        " be handled a little bit differently."
+    ),
+)
+
+bad_split1 = (
+    "But what should happen when code has already been formatted but in the wrong way?"
+    " Like with a space at the beginning instead of the end. Or what about when it is"
+    " split too soon?"
+)
+
+bad_split2 = (
+    "But what should happen when code has already "
+    "been formatted but in the wrong way? Like "
+    "with a space at the beginning instead of the "
+    "end. Or what about when it is split too "
+    "soon? In the case of a split that is too "
+    "short, black will try to honer the custom "
+    "split."
+)
+
+bad_split3 = (
+    "What if we have inline comments on "  # First Comment
+    "each line of a bad split? In that "  # Second Comment
+    "case, we should just leave it alone."  # Third Comment
+)
+
+bad_split_func1(
+    (
+        "But what should happen when code has already "
+        "been formatted but in the wrong way? Like "
+        "with a space at the beginning instead of the "
+        "end. Or what about when it is split too "
+        "soon? In the case of a split that is too "
+        "short, black will try to honer the custom "
+        "split."
+    ),
+    xxx,
+    yyy,
+    zzz,
+)
+
+bad_split_func2(
+    xxx,
+    yyy,
+    zzz,
+    long_string_kwarg=(
+        "But what should happen when code has already been formatted but in the wrong"
+        " way? Like with a space at the beginning instead of the end. Or what about"
+        " when it is split too soon?"
+    ),
+)
+
+bad_split_func3(
+    (
+        "But what should happen when code has already "
+        r"been formatted but in the wrong way? Like "
+        "with a space at the beginning instead of the "
+        r"end. Or what about when it is split too "
+        r"soon? In the case of a split that is too "
+        "short, black will try to honer the custom "
+        "split."
+    ),
+    xxx,
+    yyy,
+    zzz,
+)
+
+raw_string = (
+    r"This is a long raw string. When re-formatting this string, black needs to make"
+    r" sure it prepends the 'r' onto the new string."
+)
+
+fmt_string1 = (
+    "We also need to be sure to preserve any and all {} which may or may not be"
+    " attached to the string in question.".format("method calls")
+)
+
+fmt_string2 = "But what about when the string is {} but {}".format(
+    "short",
+    "the method call is really really really really really really really really long?",
+)
+
+old_fmt_string1 = (
+    "While we are on the topic of %s, we should also note that old-style formatting"
+    " must also be preserved, since some %s still uses it."
+    % ("formatting", "code")
+)
+
+old_fmt_string2 = "This is a %s %s %s %s" % (
+    "really really really really really",
+    "old",
+    "way to format strings!",
+    "Use f-strings instead!",
+)
+
+old_fmt_string3 = (
+    "Whereas only the strings after the percent sign were long in the last example,"
+    " this example uses a long initial string as well. This is another %s %s %s %s"
+    % (
+        "really really really really really",
+        "old",
+        "way to format strings!",
+        "Use f-strings instead!",
+    )
+)
+
+fstring = (
+    f"f-strings definitely make things more {difficult} than they need to be for"
+    " black. But boy they sure are handy. The problem is that some lines will need to"
+    f" have the 'f' whereas others do not. This {line}, for example, needs one."
+)
+
+comment_string = (  # This comment gets thrown to the top.
+    "Long lines with inline comments should have their comments appended to the"
+    " reformatted string's enclosing right parentheses."
+)
+
+arg_comment_string = print(
+    (  # This comment gets thrown to the top.
+        "Long lines with inline comments which are apart of (and not the only member"
+        " of) an argument list should have their comments appended to the reformatted"
+        " string's enclosing left parentheses."
+    ),
+    "Arg #2",
+    "Arg #3",
+    "Arg #4",
+    "Arg #5",
+)
+
+pragma_comment_string1 = "Lines which end with an inline pragma comment of the form `# <pragma>: <...>` should be left alone."  # noqa: E501
+
+pragma_comment_string2 = "Lines which end with an inline pragma comment of the form `# <pragma>: <...>` should be left alone."  # noqa
+
+"""This is a really really really long triple quote string and it should not be touched."""
+
+triple_quote_string = """This is a really really really long triple quote string assignment and it should not be touched."""
+
+# Regression test. There was a bug where tuples were being identified as long strings.
+long_tuple = (
+    "Apple",
+    "Berry",
+    "Cherry",
+    "Dill",
+    "Evergreen",
+    "Fig",
+    "Grape",
+    "Harry",
+    "Iglu",
+    "Jaguar",
+)
+
+assert some_type_of_boolean_expression, (
+    "Followed by a really really really long string that is used to provide context to"
+    " the AssertionError exception."
+)
+
+assert some_type_of_boolean_expression, (
+    "Followed by a really really really long string that is used to provide context to"
+    " the AssertionError exception, which uses dynamic string {}.".format("formatting")
+)
+
+assert some_type_of_boolean_expression, (
+    "Followed by a really really really long string that is used to provide context to"
+    " the AssertionError exception, which uses dynamic string %s."
+    % "formatting"
+)
+
+assert some_type_of_boolean_expression, (
+    "Followed by a really really really long string that is used to provide context to"
+    " the AssertionError exception, which uses dynamic %s %s."
+    % ("string", "formatting")
+)
+
+some_function_call(
+    "With a reallly generic name and with a really really long string that is, at some"
+    " point down the line, "
+    + added
+    + " to a variable and then added to another string."
+)
+
+some_function_call(
+    (
+        "With a reallly generic name and with a really really long string that is, at"
+        " some point down the line, "
+        + added
+        + " to a variable and then added to another string. But then what happens when"
+        " the final string is also supppppperrrrr long?! Well then that second"
+        " (realllllllly long) string should be split too."
+    ),
+    "and a second argument",
+    and_a_third,
+)
+
+return (
+    "A really really really really really really really really really really really"
+    " really really long {} {}".format("return", "value")
+)
+
+func_with_bad_comma(
+    "This is a really long string argument to a function that has a trailing comma"
+    " which should NOT be there."
+)
+
+func_with_bad_comma(
+    "This is a really long string argument to a function that has a trailing comma"
+    " which should NOT be there."  # comment after comma
+)
+
+func_with_bad_comma(
+    "This is a really long string argument to a function that has a trailing comma"
+    " which should NOT be there."
+)
+
+func_with_bad_comma(
+    "This is a really long string argument to a function that has a trailing comma"
+    " which should NOT be there."  # comment after comma
+)
+
+func_with_bad_parens(
+    "short string that should have parens stripped", x, y, z,
+)
+
+func_with_bad_parens(
+    x, y, "short string that should have parens stripped", z,
+)
+
+########## REGRESSION TESTS ##########
+stupid_format_method_bug = (
+    "Some really long string that just so happens to be the {} {} to force the 'format'"
+    " method to hang over the line length boundary. This is pretty annoying."
+    .format("perfect", "length")
+)
+
+
+class A:
+    def foo():
+        os.system(
+            "This is a regression test. xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx"
+            " xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx"
+            " xxxx.".format("xxxxxxxxxx", "xxxxxx", "xxxxxxxxxx")
+        )
+
+
+class A:
+    def foo():
+        XXXXXXXXXXXX.append(
+            (
+                (
+                    "xxx_xxxxxxxxxx(xxxxx={}, xxxx={}, xxxxx, xxxx_xxxx_xxxxxxxxxx={})"
+                    .format(xxxxx, xxxx, xxxx_xxxx_xxxxxxxxxx)
+                ),
+                my_var,
+                my_other_var,
+            )
+        )
+
+
+class A:
+    class B:
+        def foo():
+            bar(
+                (
+                    "[{}]: xxx_xxxxxxxxxx(xxxxx={}, xxxx={}, xxxxx={}"
+                    " xxxx_xxxx_xxxxxxxxxx={}, xxxx={})"
+                    .format(
+                        xxxx._xxxxxxxxxxxxxx, xxxxx, xxxx, xxxx_xxxx_xxxxxxxxxx, xxxxxxx
+                    )
+                ),
+                varX,
+                varY,
+                varZ,
+            )
+
+
+def foo(xxxx):
+    for (xxx_xxxx, _xxx_xxx, _xxx_xxxxx, xxx_xxxx) in xxxx:
+        for xxx in xxx_xxxx:
+            assert ("x" in xxx) or (xxx in xxx_xxx_xxxxx), (
+                "{0} xxxxxxx xx {1}, xxx {1} xx xxx xx xxxx xx xxx xxxx: xxx xxxx {2}"
+                .format(xxx_xxxx, xxx, xxxxxx.xxxxxxx(xxx_xxx_xxxxx))
+            )
+
+
+class A:
+    def disappearing_comment():
+        return (
+            (  # xx -x xxxxxxx xx xxx xxxxxxx.
+                "{{xxx_xxxxxxxxxx_xxxxxxxx}} xxx xxxx {} {{xxxx}} >&2".format(
+                    "{xxxx} {xxxxxx}"
+                    if xxxxx.xx_xxxxxxxxxx
+                    else (  # Disappearing Comment
+                        "--xxxxxxx --xxxxxx=x --xxxxxx-xxxxx=xxxxxx"
+                        " --xxxxxx-xxxx=xxxxxxxxxxx.xxx"
+                    )
+                )
+            ),
+            (x, y, z),
+        )
+
+
+class A:
+    class B:
+        def foo():
+            xxxxx_xxxx(
+                xx,
+                (
+                    "\t"
+                    "@xxxxxx '{xxxx_xxx}\t' > {xxxxxx_xxxx}.xxxxxxx;"
+                    "{xxxx_xxx} >> {xxxxxx_xxxx}.xxxxxxx 2>&1; xx=$$?;"
+                    "xxxx $$xx"
+                    .format(
+                        xxxx_xxx=xxxx_xxxxxxx,
+                        xxxxxx_xxxx=xxxxxxx + "/" + xxxx_xxx_xxxx,
+                        x=xxx_xxxxx_xxxxx_xxx,
+                    )
+                ),
+                x,
+                y,
+                z,
+            )
diff --git a/tests/data/remove_parens.py b/tests/data/remove_parens.py
index afc3401..df049fd 100644
--- a/tests/data/remove_parens.py
+++ b/tests/data/remove_parens.py
@@ -76,7 +76,9 @@ async def show_status():
 
 
 def example():
-    return "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
+    return (
+        "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
+    )
 
 
 def example1():
diff --git a/tests/data/string_quotes.py b/tests/data/string_quotes.py
index 6b68699..5a4bc5d 100644
--- a/tests/data/string_quotes.py
+++ b/tests/data/string_quotes.py
@@ -79,12 +79,7 @@ r"Date d\'expiration:(.*)"
 r'Tricky "quote'
 r"Not-so-tricky \"quote"
 rf"{yay}"
-"\n\
-The \"quick\"\n\
-brown fox\n\
-jumps over\n\
-the 'lazy' dog.\n\
-"
+"\nThe \"quick\"\nbrown fox\njumps over\nthe 'lazy' dog.\n"
 re.compile(r'[\\"]')
 "x = ''; y = \"\""
 "x = '''; y = \"\""
@@ -104,4 +99,4 @@ f"{{y * \" \"}} '{z}'"
 f'\'{z}\' {y * " "}'
 f"{y * x} '{z}'"
 "'{z}' {y * \" \"}"
-"{y * x} '{z}'"
\ No newline at end of file
+"{y * x} '{z}'"
diff --git a/tests/test_black.py b/tests/test_black.py
index 40bde36..d1db142 100644
--- a/tests/test_black.py
+++ b/tests/test_black.py
@@ -243,8 +243,8 @@ class BlackTestCase(unittest.TestCase):
 
     def test_piping_diff(self) -> None:
         diff_header = re.compile(
-            rf"(STDIN|STDOUT)\t\d\d\d\d-\d\d-\d\d "
-            rf"\d\d:\d\d:\d\d\.\d\d\d\d\d\d \+\d\d\d\d"
+            rf"(STDIN|STDOUT)\t\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d\.\d\d\d\d\d\d "
+            rf"\+\d\d\d\d"
         )
         source, _ = read_data("expression.py")
         expected, _ = read_data("expression.diff")
@@ -333,7 +333,7 @@ class BlackTestCase(unittest.TestCase):
         tmp_file = Path(black.dump_to_file(source))
         diff_header = re.compile(
             rf"{re.escape(str(tmp_file))}\t\d\d\d\d-\d\d-\d\d "
-            rf"\d\d:\d\d:\d\d\.\d\d\d\d\d\d \+\d\d\d\d"
+            r"\d\d:\d\d:\d\d\.\d\d\d\d\d\d \+\d\d\d\d"
         )
         try:
             result = BlackRunner().invoke(black.main, ["--diff", str(tmp_file)])
@@ -346,9 +346,9 @@ class BlackTestCase(unittest.TestCase):
         if expected != actual:
             dump = black.dump_to_file(actual)
             msg = (
-                f"Expected diff isn't equal to the actual. If you made changes "
-                f"to expression.py and this is an anticipated difference, "
-                f"overwrite tests/data/expression.diff with {dump}"
+                "Expected diff isn't equal to the actual. If you made changes to "
+                "expression.py and this is an anticipated difference, overwrite "
+                f"tests/data/expression.diff with {dump}"
             )
             self.assertEqual(expected, actual, msg)
 
@@ -386,10 +386,18 @@ class BlackTestCase(unittest.TestCase):
         black.assert_stable(source, actual, black.FileMode())
         mode = black.FileMode(string_normalization=False)
         not_normalized = fs(source, mode=mode)
-        self.assertFormatEqual(source, not_normalized)
+        self.assertFormatEqual(source.replace("\\\n", ""), not_normalized)
         black.assert_equivalent(source, not_normalized)
         black.assert_stable(source, not_normalized, mode=mode)
 
+    @patch("black.dump_to_file", dump_to_stderr)
+    def test_long_strings(self) -> None:
+        source, expected = read_data("long_strings")
+        actual = fs(source)
+        self.assertFormatEqual(expected, actual)
+        black.assert_equivalent(source, actual)
+        black.assert_stable(source, actual, black.FileMode())
+
     @patch("black.dump_to_file", dump_to_stderr)
     def test_slices(self) -> None:
         source, expected = read_data("slices")
@@ -728,8 +736,10 @@ class BlackTestCase(unittest.TestCase):
             self.assertEqual(err_lines[-1], "error: cannot format e1: boom")
             self.assertEqual(
                 unstyle(str(report)),
-                "1 file reformatted, 2 files left unchanged, "
-                "1 file failed to reformat.",
+                (
+                    "1 file reformatted, 2 files left unchanged, 1 file failed to "
+                    "reformat."
+                ),
             )
             self.assertEqual(report.return_code, 123)
             report.done(Path("f3"), black.Changed.YES)
@@ -738,8 +748,10 @@ class BlackTestCase(unittest.TestCase):
             self.assertEqual(out_lines[-1], "reformatted f3")
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "1 file failed to reformat.",
+                (
+                    "2 files reformatted, 2 files left unchanged, 1 file failed to "
+                    "reformat."
+                ),
             )
             self.assertEqual(report.return_code, 123)
             report.failed(Path("e2"), "boom")
@@ -748,8 +760,10 @@ class BlackTestCase(unittest.TestCase):
             self.assertEqual(err_lines[-1], "error: cannot format e2: boom")
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "2 files failed to reformat.",
+                (
+                    "2 files reformatted, 2 files left unchanged, 2 files failed to "
+                    "reformat."
+                ),
             )
             self.assertEqual(report.return_code, 123)
             report.path_ignored(Path("wat"), "no match")
@@ -758,8 +772,10 @@ class BlackTestCase(unittest.TestCase):
             self.assertEqual(out_lines[-1], "wat ignored: no match")
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "2 files failed to reformat.",
+                (
+                    "2 files reformatted, 2 files left unchanged, 2 files failed to "
+                    "reformat."
+                ),
             )
             self.assertEqual(report.return_code, 123)
             report.done(Path("f4"), black.Changed.NO)
@@ -768,15 +784,19 @@ class BlackTestCase(unittest.TestCase):
             self.assertEqual(out_lines[-1], "f4 already well formatted, good job.")
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 3 files left unchanged, "
-                "2 files failed to reformat.",
+                (
+                    "2 files reformatted, 3 files left unchanged, 2 files failed to "
+                    "reformat."
+                ),
             )
             self.assertEqual(report.return_code, 123)
             report.check = True
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files would be reformatted, 3 files would be left unchanged, "
-                "2 files would fail to reformat.",
+                (
+                    "2 files would be reformatted, 3 files would be left unchanged, 2 "
+                    "files would fail to reformat."
+                ),
             )
 
     def test_report_quiet(self) -> None:
@@ -818,8 +838,10 @@ class BlackTestCase(unittest.TestCase):
             self.assertEqual(err_lines[-1], "error: cannot format e1: boom")
             self.assertEqual(
                 unstyle(str(report)),
-                "1 file reformatted, 2 files left unchanged, "
-                "1 file failed to reformat.",
+                (
+                    "1 file reformatted, 2 files left unchanged, 1 file failed to "
+                    "reformat."
+                ),
             )
             self.assertEqual(report.return_code, 123)
             report.done(Path("f3"), black.Changed.YES)
@@ -827,8 +849,10 @@ class BlackTestCase(unittest.TestCase):
             self.assertEqual(len(err_lines), 1)
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "1 file failed to reformat.",
+                (
+                    "2 files reformatted, 2 files left unchanged, 1 file failed to "
+                    "reformat."
+                ),
             )
             self.assertEqual(report.return_code, 123)
             report.failed(Path("e2"), "boom")
@@ -837,8 +861,10 @@ class BlackTestCase(unittest.TestCase):
             self.assertEqual(err_lines[-1], "error: cannot format e2: boom")
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "2 files failed to reformat.",
+                (
+                    "2 files reformatted, 2 files left unchanged, 2 files failed to "
+                    "reformat."
+                ),
             )
             self.assertEqual(report.return_code, 123)
             report.path_ignored(Path("wat"), "no match")
@@ -846,8 +872,10 @@ class BlackTestCase(unittest.TestCase):
             self.assertEqual(len(err_lines), 2)
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "2 files failed to reformat.",
+                (
+                    "2 files reformatted, 2 files left unchanged, 2 files failed to "
+                    "reformat."
+                ),
             )
             self.assertEqual(report.return_code, 123)
             report.done(Path("f4"), black.Changed.NO)
@@ -855,15 +883,19 @@ class BlackTestCase(unittest.TestCase):
             self.assertEqual(len(err_lines), 2)
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 3 files left unchanged, "
-                "2 files failed to reformat.",
+                (
+                    "2 files reformatted, 3 files left unchanged, 2 files failed to "
+                    "reformat."
+                ),
             )
             self.assertEqual(report.return_code, 123)
             report.check = True
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files would be reformatted, 3 files would be left unchanged, "
-                "2 files would fail to reformat.",
+                (
+                    "2 files would be reformatted, 3 files would be left unchanged, 2 "
+                    "files would fail to reformat."
+                ),
             )
 
     def test_report_normal(self) -> None:
@@ -907,8 +939,10 @@ class BlackTestCase(unittest.TestCase):
             self.assertEqual(err_lines[-1], "error: cannot format e1: boom")
             self.assertEqual(
                 unstyle(str(report)),
-                "1 file reformatted, 2 files left unchanged, "
-                "1 file failed to reformat.",
+                (
+                    "1 file reformatted, 2 files left unchanged, 1 file failed to "
+                    "reformat."
+                ),
             )
             self.assertEqual(report.return_code, 123)
             report.done(Path("f3"), black.Changed.YES)
@@ -917,8 +951,10 @@ class BlackTestCase(unittest.TestCase):
             self.assertEqual(out_lines[-1], "reformatted f3")
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "1 file failed to reformat.",
+                (
+                    "2 files reformatted, 2 files left unchanged, 1 file failed to "
+                    "reformat."
+                ),
             )
             self.assertEqual(report.return_code, 123)
             report.failed(Path("e2"), "boom")
@@ -927,8 +963,10 @@ class BlackTestCase(unittest.TestCase):
             self.assertEqual(err_lines[-1], "error: cannot format e2: boom")
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "2 files failed to reformat.",
+                (
+                    "2 files reformatted, 2 files left unchanged, 2 files failed to "
+                    "reformat."
+                ),
             )
             self.assertEqual(report.return_code, 123)
             report.path_ignored(Path("wat"), "no match")
@@ -936,8 +974,10 @@ class BlackTestCase(unittest.TestCase):
             self.assertEqual(len(err_lines), 2)
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "2 files failed to reformat.",
+                (
+                    "2 files reformatted, 2 files left unchanged, 2 files failed to "
+                    "reformat."
+                ),
             )
             self.assertEqual(report.return_code, 123)
             report.done(Path("f4"), black.Changed.NO)
@@ -945,15 +985,19 @@ class BlackTestCase(unittest.TestCase):
             self.assertEqual(len(err_lines), 2)
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 3 files left unchanged, "
-                "2 files failed to reformat.",
+                (
+                    "2 files reformatted, 3 files left unchanged, 2 files failed to "
+                    "reformat."
+                ),
             )
             self.assertEqual(report.return_code, 123)
             report.check = True
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files would be reformatted, 3 files would be left unchanged, "
-                "2 files would fail to reformat.",
+                (
+                    "2 files would be reformatted, 3 files would be left unchanged, 2 "
+                    "files would fail to reformat."
+                ),
             )
 
     def test_lib2to3_parse(self) -> None:
@@ -1704,8 +1748,7 @@ class BlackDTestCase(AioHTTPTestCase):
     @unittest_run_loop
     async def test_blackd_diff(self) -> None:
         diff_header = re.compile(
-            rf"(In|Out)\t\d\d\d\d-\d\d-\d\d "
-            rf"\d\d:\d\d:\d\d\.\d\d\d\d\d\d \+\d\d\d\d"
+            rf"(In|Out)\t\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d\.\d\d\d\d\d\d \+\d\d\d\d"
         )
 
         source, _ = read_data("blackd_diff.py")
